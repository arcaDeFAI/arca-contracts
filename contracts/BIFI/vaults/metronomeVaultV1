pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "./interfaces/ILBRouter.sol";
import "./interfaces/ILBHooksBaseRewarder.sol";
import "./interfaces/ILBPair.sol";

/**
 * @dev Implementation of a vault to deposit funds for yield optimizing.
 * This is the contract that receives funds and that users interface with.
 * Rebalancing functionality is implemented directly in this contract.
 */
contract MetronomeVaultV1 is ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    // State variables 
    address public tokenX; // Main token X that the vault will hold
    address public tokenY; // Main token Y that the vault will hold
    uint16 public binStep; // The bin step for liquidity positions
    uint256 public amountXMin; // Minimum amount of token X to add during rebalance
    uint256 public amountYMin; // Minimum amount of token Y to add during rebalance
    uint256 public idSlippage; // The number of bins to slip
    address public lbRouter; // Address of the LB Router contract
    address public lbpContract; // Address of the LBP contract
    address public rewarder; // Address of the LBHooksBaseRewarder contract
    
    event Rebalanced(
        address tokenX, 
        address tokenY, 
        uint256 amountXAdded, 
        uint256 amountYAdded, 
        uint256 amountXRemoved, 
        uint256 amountYRemoved
    );
    
    event RewardsClaimed(
        address rewarder,
        address token,
        uint256 amount
    );

    /**
     * @dev Initializes the vault's own token.
     * This token is minted when someone does a deposit. It is burned in order
     * to withdraw the corresponding portion of the underlying assets.
     * @param _tokenX the address of the tokenX that the vault will hold as underlying value.
     * @param _tokenY the address of the tokenY that the vault will hold as underlying value.
     * @param _binStep the bin step for the liquidity positions
     * @param _amountXMin the minimum amount of tokenX to add during rebalance
     * @param _amountYMin the minimum amount of tokenY to add during rebalance
     * @param _idSlippage the number of bins to slip
     * @param _name the name of the vault token ''Metronome WS-SCUSD Vault''.
     * @param _symbol the symbol of the vault token ''fanaWSSC.
     * @param _lbRouter the address of the LB Router
     * @param _lbpContract the address of the LBP contract
     * @param _rewarder the address of the LBHooksBaseRewarder contract
     */
    function initialize(
        address _tokenX,
        address _tokenY,
        uint16 _binStep,
        uint256 _amountXMin,
        uint256 _amountYMin,
        uint256 _idSlippage,
        string memory _name,
        string memory _symbol,
        address _lbRouter,
        address _lbpContract,
        address _rewarder
    ) public initializer {
        __ERC20_init(_name, _symbol);
        __Ownable_init();
        __ReentrancyGuard_init();
        
        tokenX = _tokenX;
        tokenY = _tokenY;
        binStep = _binStep;
        amountXMin = _amountXMin;
        amountYMin = _amountYMin;
        idSlippage = _idSlippage;
        lbRouter = _lbRouter;
        lbpContract = _lbpContract;
        rewarder = _rewarder;
    }

    /**
     * @dev It calculates the total underlying value of tokenX held by the system.
     * It takes into account the vault contract balance.
     */
    function balanceX() public view returns (uint256) {
        return IERC20Upgradeable(tokenX).balanceOf(address(this));
    }

    /**
     * @dev It calculates the total underlying value of tokenY held by the system.
     * It takes into account the vault contract balance.
     */
    function balanceY() public view returns (uint256) {
        return IERC20Upgradeable(tokenY).balanceOf(address(this));
    }

    /**
     * @dev Custom logic in here for how much the vault allows to be borrowed.
     * We return 100% of tokens for now. Under certain conditions we might
     * want to keep some of the system funds at hand in the vault, instead
     * of putting them to work.
     */
    function availableX() public view returns (uint256) {
        return IERC20Upgradeable(tokenX).balanceOf(address(this));
    }

    /**
     * @dev Custom logic in here for how much the vault allows to be borrowed.
     * We return 100% of tokens for now. Under certain conditions we might
     * want to keep some of the system funds at hand in the vault, instead
     * of putting them to work.
     */
    function availableY() public view returns (uint256) {
        return IERC20Upgradeable(tokenY).balanceOf(address(this));
    }

    /**
     * @dev Function for various UIs to display the current value of one of our yield tokens.
     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.
     * This is a simplified implementation that considers only tokenX for share value calculation.
     * For more advanced implementations, consider both tokens' values.
     */
    function getPricePerFullShare() public view returns (uint256) {
        return totalSupply() == 0 ? 1e18 : balanceX() * 1e18 / totalSupply();
    }

    /**
     * @dev A helper function to call depositX() with all the sender's funds.
     */
    function depositAllX() external {
        depositX(IERC20Upgradeable(tokenX).balanceOf(msg.sender));
    }

    /**
     * @dev A helper function to call depositY() with all the sender's funds.
     */
    function depositAllY() external {
        depositY(IERC20Upgradeable(tokenY).balanceOf(msg.sender));
    }

    /**
     * @dev The entrypoint of tokenX funds into the system. People deposit with this function
     * into the vault.
     */
    function depositX(uint256 _amount) public nonReentrant {
        uint256 _pool = balanceX();
        IERC20Upgradeable(tokenX).safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _after = balanceX();
        _amount = _after - _pool; // Additional check for deflationary tokens
        uint256 shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount * totalSupply()) / _pool;
        }
        _mint(msg.sender, shares);
    }

    /**
     * @dev The entrypoint of tokenY funds into the system. People deposit with this function
     * into the vault.
     */
    function depositY(uint256 _amount) public nonReentrant {
        uint256 _pool = balanceY();
        IERC20Upgradeable(tokenY).safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _after = balanceY();
        _amount = _after - _pool; // Additional check for deflationary tokens
        uint256 shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount * totalSupply()) / _pool;
        }
        _mint(msg.sender, shares);
    }

    /**
     * @dev A helper function to call withdraw() with all the sender's funds.
     */
    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    /**
     * @dev Function to exit the system. The vault will withdraw the required tokens
     * from the strategy and pay up the token holder. A proportional number of IOU
     * tokens are burned in the process.
     * This is a simplified implementation - in a production environment, consider
     * how to properly handle withdrawal of both tokenX and tokenY.
     */
    function withdraw(uint256 _shares) public nonReentrant {
        uint256 totalShares = totalSupply();
        require(totalShares > 0, "No shares in supply");
        
        // Calculate the proportional amounts of tokenX and tokenY
        uint256 amountX = (balanceX() * _shares) / totalShares;
        uint256 amountY = (balanceY() * _shares) / totalShares;
        
        _burn(msg.sender, _shares);
        
        if (amountX > 0) {
            IERC20Upgradeable(tokenX).safeTransfer(msg.sender, amountX);
        }
        
        if (amountY > 0) {
            IERC20Upgradeable(tokenY).safeTransfer(msg.sender, amountY);
        }
    }

    /**
     * @dev Rebalance function that combines addLiquidity and removeLiquidity functionality
     * This function is external and can only be called by the owner
     * It performs safety checks and is compliant with fee on transfer tokens
     * It will use all available tokens in the vault including previously deposited tokens
     * @param activeIdDesired The desired active bin id
     * @param deltaIds The bin ids deltas
     * @param distributionX The distribution of tokenX
     * @param distributionY The distribution of tokenY
     * @param ids Array of bin ids for removal
     * @param amounts Array of amounts to remove
     * @param removeAmountXMin The min amount to receive of token X during removal
     * @param removeAmountYMin The min amount to receive of token Y during removal
     * @param to The address of the recipient
     * @param refundTo The address that will receive potential refunds
     * @param deadline The deadline of the tx
     * @param forceRebalance If true, will remove liquidity first before adding (for rebalancing)
     *                      If false, will only add liquidity (for first time)
     * @return amountXAdded Amount of token X added
     * @return amountYAdded Amount of token Y added
     * @return amountXRemoved Amount of token X removed
     * @return amountYRemoved Amount of token Y removed
     */
    function rebalance(
        uint256 activeIdDesired,
        int256[] calldata deltaIds,
        uint256[] calldata distributionX,
        uint256[] calldata distributionY,
        // Remove liquidity params
        uint256[] calldata ids,
        uint256[] calldata amounts,
        uint256 removeAmountXMin,
        uint256 removeAmountYMin,
        // Shared params
        address to,
        address refundTo,
        uint256 deadline,
        // Control param
        bool forceRebalance
    ) external onlyOwner nonReentrant returns (
        uint256 amountXAdded,
        uint256 amountYAdded,
        uint256 amountXRemoved,
        uint256 amountYRemoved
    ) {
        require(block.timestamp <= deadline, "Transaction expired");
        
        // Check available balances of tokenX and tokenY in the vault before any operations
        uint256 availableX = IERC20Upgradeable(tokenX).balanceOf(address(this));
        uint256 availableY = IERC20Upgradeable(tokenY).balanceOf(address(this));
        
        // First, handle removal of liquidity if we're rebalancing or have IDs to remove from
        if ((forceRebalance || ids.length > 0) && amounts.length > 0) {
            require(ids.length == amounts.length, "Array lengths must match");
            
            // Call the removeLiquidity function on the LBRouter
            (amountXRemoved, amountYRemoved) = ILBRouter(lbRouter).removeLiquidity(
                tokenX,
                tokenY, 
                binStep,
                removeAmountXMin,
                removeAmountYMin,
                ids,
                amounts,
                address(this),  // First send removed tokens to this contract
                deadline
            );
            
            // Update available balances after liquidity removal
            availableX = IERC20Upgradeable(tokenX).balanceOf(address(this));
            availableY = IERC20Upgradeable(tokenY).balanceOf(address(this));
        }
        
        // Then, handle adding liquidity using all available tokens in the vault
        if (availableX > 0 || availableY > 0) {
            // Use all available tokens in the vault for adding liquidity
            uint256 amountX = availableX;
            uint256 amountY = availableY;
            
            // Approve router to spend tokens
            if (amountX > 0) {
                IERC20Upgradeable(tokenX).safeApprove(lbRouter, 0); // Clear previous approvals
                IERC20Upgradeable(tokenX).safeApprove(lbRouter, amountX);
            }
            
            if (amountY > 0) {
                IERC20Upgradeable(tokenY).safeApprove(lbRouter, 0); // Clear previous approvals
                IERC20Upgradeable(tokenY).safeApprove(lbRouter, amountY);
            }
            
            // Call the actual addLiquidity function on the LBRouter
            ILBRouter.LiquidityParameters memory liquidityParams = ILBRouter.LiquidityParameters({
                tokenX: tokenX,
                tokenY: tokenY,
                binStep: binStep,
                amountX: amountX,
                amountY: amountY,
                amountXMin: amountXMin,
                amountYMin: amountYMin,
                activeIdDesired: activeIdDesired,
                idSlippage: idSlippage,
                deltaIds: deltaIds,
                distributionX: distributionX,
                distributionY: distributionY,
                to: to,
                refundTo: refundTo,
                deadline: deadline
            });
            
            (amountXAdded, amountYAdded,,,) = ILBRouter(lbRouter).addLiquidity(liquidityParams);
        }
        
        emit Rebalanced(tokenX, tokenY, amountXAdded, amountYAdded, amountXRemoved, amountYRemoved);
        
        return (amountXAdded, amountYAdded, amountXRemoved, amountYRemoved);
    }  
    
    /**
     * @dev Claims rewards from the LBHooksBaseRewarder for LP positions
     * @param rewardTokens Array of reward token addresses to claim
     * @param binIds Array of bin IDs where the vault has LP positions
     * @param receiver Address that will receive the claimed rewards
     * @return claimedAmounts Array of amounts claimed for each reward token
     */
    function claimRewards(
        address[] calldata rewardTokens,
        uint256[] calldata binIds,
        address receiver
    ) external onlyOwner nonReentrant returns (uint256[] memory claimedAmounts) {
        require(rewarder != address(0), "Rewarder not set");
        require(binIds.length > 0, "No bin IDs provided");
        require(receiver != address(0), "Invalid receiver address");
        
        // Get the LBPair address from the LBP contract
        address lbPair = lbpContract;
        require(lbPair != address(0), "LBPair not set");
        
        // Claim rewards from the LBHooksBaseRewarder
        claimedAmounts = ILBHooksBaseRewarder(rewarder).claim(
            lbPair,
            address(this), // The vault is the claim address
            binIds,
            rewardTokens,
            receiver
        );
        
        // Emit events for each reward token claimed
        for (uint256 i = 0; i < rewardTokens.length; i++) {
            emit RewardsClaimed(rewarder, rewardTokens[i], claimedAmounts[i]);
        }
        
        return claimedAmounts;
    }

    /**
     * @dev Returns the bin IDs where the vault has LP positions
     * @return Array of bin IDs
     */
    function getVaultBinIds() public view returns (uint256[] memory) {
        address lbPair = lbpContract;
        
        // Get the current active bin ID
        uint256 activeId = ILBPair(lbPair).getActiveId();
        
        // Get positions around the active ID (this is a simplified implementation)
        // In a real implementation, you would query actual position IDs from the LBPair
        uint256[] memory binIds = new uint256[](2 * idSlippage + 1);
        
        for (uint256 i = 0; i < 2 * idSlippage + 1; i++) {
            binIds[i] = activeId - idSlippage + i;
        }
        
        return binIds;
    }
    
    /**
     * @dev Helper function to claim rewards for all vault positions
     * @param rewardTokens Array of reward token addresses to claim
     * @param receiver Address that will receive the claimed rewards
     * @return claimedAmounts Array of amounts claimed for each reward token
     */
    function claimAllRewards(
        address[] calldata rewardTokens,
        address receiver
    ) external onlyOwner returns (uint256[] memory claimedAmounts) {
        uint256[] memory binIds = getVaultBinIds();
        return claimRewards(rewardTokens, binIds, receiver);
    }

    /**
     * @dev Rescues random funds stuck that the contract can't handle.
     * @param _token address of the token to rescue.
     */
    function inCaseTokensGetStuck(address _token) external onlyOwner {
        require(_token != tokenX && _token != tokenY, "Cannot withdraw vault tokens");

        uint256 amount = IERC20Upgradeable(_token).balanceOf(address(this));
        IERC20Upgradeable(_token).safeTransfer(msg.sender, amount);
    }
    
    /**
     * @dev Updates the rewarder address
     * @param _rewarder New rewarder address
     */
    function setRewarder(address _rewarder) external onlyOwner {
        require(_rewarder != address(0), "Invalid rewarder address");
        rewarder = _rewarder;
    }
}
